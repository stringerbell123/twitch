# -*- coding: utf-8 -*-
"""Untitled12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tqeLF2-ndMoHtehRMXCV4lO8HlxpezYh
"""

# Install required packages
!pip install pyngrok requests pandas streamlit
!pkill -f ngrok || echo "No existing ngrok processes"
!rm -rf /root/.ngrok2/ || echo "No ngrok config found"

# Import libraries
import requests
import pandas as pd
import subprocess
import time
from pyngrok import ngrok
from datetime import datetime

# ======================
# Twitch API Configuration
# ======================
CLIENT_ID = '8syjbj1r4j8w8taepicc52aq3gme94'          # üîë Replace these
CLIENT_SECRET = 'qpv6ok8pebeqtt4dzjk2y58mo37zlf'  # üîí Get from Twitch Dev Console

# Get Twitch Access Token
def get_twitch_token():
    try:
        response = requests.post(
            'https://id.twitch.tv/oauth2/token',
            params={
                'client_id': CLIENT_ID,
                'client_secret': CLIENT_SECRET,
                'grant_type': 'client_credentials'
            }
        )
        response.raise_for_status()
        return response.json()['access_token']
    except Exception as e:
        print(f"‚ùå Twitch auth failed: {str(e)}")
        return None

# ======================
# Stream Data Fetching
# ======================
def get_diverse_streams(categories, token, min_viewers=100, limit_per_category=15):
    """Get unique, high-quality streams with pagination"""
    headers = {
        'Client-ID': CLIENT_ID,
        'Authorization': f'Bearer {token}'
    }

    unique_streams = []

    for category in categories:
        cursor = None
        category_streams = []

        while len(category_streams) < limit_per_category:
            params = {
                'first': 100,
                'game_name': category,
                'after': cursor
            }

            try:
                response = requests.get(
                    'https://api.twitch.tv/helix/streams',
                    headers=headers,
                    params=params
                )
                response.raise_for_status()
                data = response.json()

                # Filter and deduplicate
                for stream in data.get('data', []):
                    if (stream['viewer_count'] >= min_viewers and
                        not any(s['user_id'] == stream['user_id'] for s in unique_streams)):
                        category_streams.append(stream)
                        if len(category_streams) >= limit_per_category:
                            break

                cursor = data.get('pagination', {}).get('cursor')
                if not cursor: break

            except Exception as e:
                print(f"‚ö†Ô∏è Error fetching {category}: {str(e)}")
                break

        unique_streams.extend(category_streams)
        print(f"‚úÖ Found {len(category_streams)} streams for {category}")
        time.sleep(0.5)  # Rate limit

    return unique_streams

# ======================
# Generate Streamlit App
# ======================
APP_CODE = """
import streamlit as st
import pandas as pd
from datetime import datetime

# Initialize theme
if 'dark_mode' not in st.session_state:
    st.session_state.dark_mode = True

# Custom CSS for both modes
st.markdown(\"\"\"
    <style>
    :root {
        --primary: #9147FF;
        --bg: #0E0E10;
        --card-bg: #18181B;
        --text: #FFFFFF;
    }
    [data-theme="light"] {
        --primary: #5C16C5;
        --bg: #FFFFFF;
        --card-bg: #F7F7F8;
        --text: #000000;
    }
    .stream-card {
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        background: var(--card-bg);
        border-left: 4px solid var(--primary);
        color: var(--text);
    }
    .viewer-count {
        color: #00FF7F !important;
        font-weight: bold;
    }
    </style>
\"\"\", unsafe_allow_html=True)

# Load data
try:
    df = pd.read_csv("streams.csv")
    df['Started'] = pd.to_datetime(df['Started'])
    df = df.sort_values('Viewers', ascending=False)
except Exception as e:
    st.error(f"Data load failed: {str(e)}")
    st.stop()

# Sidebar controls
with st.sidebar:
    # Theme toggle
    st.button(
        "üåô/‚òÄÔ∏è",
        on_click=lambda: st.session_state.update(dark_mode=not st.session_state.dark_mode)
    )
    st.markdown(f"**Current Mode:** {'üåô Dark' if st.session_state.dark_mode else '‚òÄÔ∏è Light'}")

    st.title("üîç Filters")

    # Multi-category select
    selected_games = st.multiselect(
        "Choose categories:",
        options=sorted(df['Game'].unique()),
        default=["Just Chatting"]
    )

    # Stream limit slider
    stream_limit = st.slider(
        "Max streams to show:",
        min_value=5,
        max_value=50,
        value=20,
        step=5
    )

    min_viewers = st.slider(
        "Minimum viewers:",
        min_value=0,
        max_value=5000,
        value=100,
        step=100
    )

# Apply theme
theme = "dark" if st.session_state.dark_mode else "light"
st.markdown(f"<body data-theme='{theme}'>", unsafe_allow_html=True)

# Filter streams
if not selected_games:
    st.warning("Please select at least one category")
    st.stop()

filtered = df[
    (df['Game'].isin(selected_games)) &
    (df['Viewers'] >= min_viewers)
].head(stream_limit)  # Apply stream limit

# Display
st.title(f"üéÆ {' + '.join(selected_games)} Streams")
st.caption(f"üì∫ Showing {len(filtered)} of {len(df)} total streams")

for _, row in filtered.iterrows():
    with st.container():
        st.markdown(f\"\"\"
        <div class="stream-card">
            <div style="display:flex; gap:20px; align-items:center">
                <div style="flex:3">
                    <h3>{row['Streamer']}</h3>
                    <p>{row['Title']}</p>
                    <div style="display:flex; gap:15px; margin-top:10px">
                        <span class="viewer-count">üëÄ {row['Viewers']:,} viewers</span>
                        <span>‚è±Ô∏è {row['Started'].strftime('%H:%M')}</span>
                        <span>üéÆ {row['Game']}</span>
                    </div>
                </div>
                <div style="flex:1; text-align:center">
                    <a href="https://twitch.tv/{row['Streamer']}" target="_blank">
                        <button style="background:var(--primary); color:white; border:none; padding:8px 16px; border-radius:5px">
                            Watch Live
                        </button>
                    </a>
                </div>
            </div>
        </div>
        \"\"\", unsafe_allow_html=True)
"""

# Save app file
with open("app.py", "w") as f:
    f.write(APP_CODE)

# ======================
# Main Execution
# ======================
if __name__ == "__main__":
    # Get Twitch token
    access_token = get_twitch_token()
    if not access_token:
        exit()

    # Top categories to monitor (expanded list)
    TOP_CATEGORIES = [
        "Just Chatting", "League of Legends", "Valorant",
        "Minecraft", "Grand Theft Auto V", "Fortnite",
        "Call of Duty", "Dota 2", "Apex Legends", "Counter-Strike 2"
    ]

    # Fetch streams (now gets 15 per category)
    print("üîÑ Fetching diverse streams...")
    all_streams = get_diverse_streams(
        TOP_CATEGORIES,
        access_token,
        min_viewers=50,
        limit_per_category=15
    )

    # Create DataFrame
    stream_data = pd.DataFrame([{
        'Streamer': s['user_name'],
        'Game': s['game_name'],
        'Title': s['title'],
        'Viewers': s['viewer_count'],
        'Started': s['started_at'],
        'Thumbnail': s['thumbnail_url'].format(width=320, height=180)
    } for s in all_streams])

    # Final cleanup
    stream_data = stream_data.drop_duplicates(subset=['Streamer'])
    stream_data.to_csv("streams.csv", index=False)
    print(f"‚úÖ Saved {len(stream_data)} unique streams")

    # Start ngrok tunnel
    try:
        ngrok.set_auth_token("2vzQzLJ8e8lUSAwupojk5gJBwcq_3BWyAAbYftPBsAwgKXPDR")  # üîë Replace
        process = subprocess.Popen(
            ["streamlit", "run", "app.py", "--server.headless=true"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        time.sleep(5)
        tunnel = ngrok.connect(addr=8501, bind_tls=True)
        print(f"\nüöÄ App is LIVE at: {tunnel.public_url}")
        print("üõë Press Ctrl+C in Colab to stop")

        while True:
            time.sleep(10)
    except KeyboardInterrupt:
        print("\nShutting down...")
        process.terminate()
        ngrok.kill()
    except Exception as e:
        print(f"Error: {str(e)}")
        print("Local URL: http://localhost:8501")
        process.terminate()